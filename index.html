<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ONNX CIFARâ€‘10 VGG â€” FP32 / INT8 Comparison</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net" />
<script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
<style>
Â  :root {
Â  Â  --gap: 14px;
Â  Â  --radius: 10px;
Â  Â  --bg: #0b1324;
Â  Â  --panel: #121a2f;
Â  Â  --text: #e5ecff;
Â  Â  --muted: #9fb0d0;
Â  Â  --accent: #7aa2ff;
Â  }
Â  * { box-sizing: border-box; }
Â  html, body { height: 100%; }
Â  body {
Â  Â  margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, sans-serif;
Â  Â  color: var(--text); background: linear-gradient(180deg,#090f20,#0d1327 60%, #0b1324);
Â  }
Â  .page { max-width: 980px; margin: 0 auto; padding: 20px; }
Â  h1 { margin: 12px 0 8px; text-align: center; font-size: clamp(20px, 3vw, 28px); }
Â  .grid { display: grid; grid-template-columns: 1.1fr 1fr; gap: var(--gap); }
Â  .card { background: var(--panel); border: 1px solid #1f2b4b; border-radius: var(--radius); padding: 14px; }
Â  fieldset { border: 1px dashed #2b3b65; border-radius: var(--radius); padding: 12px; }
Â  legend { color: var(--muted); padding: 0 6px; }
Â  label { display: grid; grid-template-columns: 140px 1fr; align-items: center; gap: 8px; margin: 8px 0; }
Â  input, select { width: 100%; border: 1px solid #2b3b65; background: #0e1530; color: var(--text); padding: 8px 10px; border-radius: 8px; }
Â  input[type="number"] { appearance: textfield; }
Â  button { cursor: pointer; border: 1px solid #2b3b65; background: #122045; color: var(--text); padding: 9px 12px; border-radius: 10px; font-weight: 600; }
Â  button.primary { background: #15316e; border-color: #2a4aa0; }
Â  .row { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
Â  .drop { border: 1px dashed #2b3b65; border-radius: 12px; padding: 14px; text-align: center; color: var(--muted); }
Â  .drop.drag { border-color: var(--accent); box-shadow: 0 0 0 3px color-mix(in oklab, var(--accent), transparent 70%); }
Â  img.preview { max-width: 160px; max-height: 160px; border: 1px solid #203055; border-radius: 8px; background: #0b1128; image-rendering: pixelated; }
Â  pre.log { background: #0b1128; border: 1px solid #1f2b4b; border-radius: var(--radius); padding: 12px; max-height: 360px; overflow: auto; white-space: pre-wrap; }
Â  .pill { display:inline-flex; align-items:center; gap:6px; border:1px solid #28406f; background:#112047; padding:6px 10px; border-radius:999px; font-size: 13px; }
Â  .badge { background:#1e2f5a; padding:4px 8px; border-radius:8px; }
Â  .flex { display:flex; gap: var(--gap); }
Â  .grow { flex: 1 1 auto; }

Â  @media (max-width: 860px) {
Â  Â  .grid { grid-template-columns: 1fr; }
Â  }
Â  .hint { color: var(--muted); font-size: 12px; }
Â  .hide { display:none; }
</style>
</head>
<body>
Â  <div class="page">
Â  Â  <h1>ONNX CIFARâ€‘10 æ¨¡å‹æ¯”è¼ƒ</h1>

Â  Â  <div class="grid">
Â  Â  Â  Â  Â  Â  <div class="card">
Â  Â  Â  Â  <div class="row" style="justify-content:space-between;">
Â  Â  Â  Â  Â  <div class="row">
Â  Â  Â  Â  Â  Â  <span class="pill"><strong>Status</strong> <span id="status">Idle</span></span>
Â  Â  Â  Â  Â  Â  <span class="pill">EP: <span id="epLabel">â€”</span></span>
Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  <div class="row">
Â  Â  Â  Â  Â  Â  <button id="loadBtn" class="primary">Load / Reload Models</button> Â  Â  Â  Â  Â  Â  <button id="compareBtn" style="background:#5e7c3c; border-color:#82a95c;">Run Comparison</button> Â  Â  Â  Â  Â  Â  <button id="runBtn" class="hide">Run Inference</button> Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  </div>

Â  Â  Â  Â  <div class="row" style="margin-top: 8px; align-items:flex-start;">
Â  Â  Â  Â  Â  <div class="grow">
Â  Â  Â  Â  Â  Â  <div id="drop" class="drop">æŠŠåœ–ç‰‡æ‹–æ›³åˆ°æ­¤è™•ï¼Œæˆ–
Â  Â  Â  Â  Â  Â  Â  <label style="display:inline-grid; grid-template-columns:auto auto; gap:8px; align-items:center;">
Â  Â  Â  Â  Â  Â  Â  Â  <input id="file" type="file" accept="image/*" style="display:none;"/>
Â  Â  Â  Â  Â  Â  Â  Â  <button type="button">é¸æ“‡æª”æ¡ˆâ€¦</button>
Â  Â  Â  Â  Â  Â  Â  </label>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  <div class="row" style="margin-top: 10px;">
Â  Â  Â  Â  Â  Â  Â  <img id="preview" class="preview" alt="preview" />
Â  Â  Â  Â  Â  Â  Â  <div>
Â  Â  Â  Â  Â  Â  Â  Â  <div class="badge" id="pred1">â€”</div>
Â  Â  Â  Â  Â  Â  Â  Â  <div class="badge" id="pred2" style="margin-top:6px;">â€”</div>
Â  Â  Â  Â  Â  Â  Â  Â  <div class="badge" id="pred3" style="margin-top:6px;">â€”</div>
Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  </div>
        
        <div id="compareResult" style="margin-top: 15px; border-top: 1px solid #1f2b4b; padding-top: 15px;">
            <p style="color:var(--muted); text-align:center;">é»æ“Š "Run Comparison" å¾Œï¼Œæ­¤è™•å°‡é¡¯ç¤º FP32 èˆ‡ INT8 æ¨¡å‹çš„çµæœæ¯”è¼ƒã€‚</p>
        </div>

Â  Â  Â  Â  <h3>Log</h3>
Â  Â  Â  Â  <pre id="log" class="log">Ready.</pre>
Â  Â  Â  </div>

Â  Â  Â  Â  Â  Â  <div class="card">
Â  Â  Â  Â  <fieldset>
Â  Â  Â  Â  Â  <legend>Model</legend>
Â  Â  Â  Â  Â  <label>
Â  Â  Â  Â  Â  Â  <span>FP32 Model URL</span> Â  Â  Â  Â  Â  Â  <input id="modelUrlFP32" type="text" value="./resnet_exported.onnx" />
Â  Â  Â  Â  Â  </label>
Â  Â  Â  Â  Â  <label>
Â  Â  Â  Â  Â  Â  <span>INT8 Model URL</span> Â  Â  Â  Â  Â  Â  <input id="modelUrlINT8" type="text" value="./image_classifier_model_int8.onnx" />
Â  Â  Â  Â  Â  </label>
Â  Â  Â  Â  Â  <label>
Â  Â  Â  Â  Â  Â  <span>Execution Provider</span>
Â  Â  Â  Â  Â  Â  <select id="provider">
Â  Â  Â  Â  Â  Â  Â  <option value="wasm">wasm (default)</option>
Â  Â  Â  Â  Â  Â  Â  <option value="webgl">webgl</option>
Â  Â  Â  Â  Â  Â  </select>
Â  Â  Â  Â  Â  </label>
Â  Â  Â  Â  </fieldset>

Â  Â  Â  Â  <fieldset style="margin-top: var(--gap)">
Â  Â  Â  Â  Â  <legend>Input</legend>
Â  Â  Â  Â  Â  <label>
Â  Â  Â  Â  Â  Â  <span>Size (WÃ—H)</span>
Â  Â  Â  Â  Â  Â  <div class="row">
Â  Â  Â  Â  Â  Â  Â  <input id="inW" type="number" min="8" value="32" style="max-width:90px" />
Â  Â  Â  Â  Â  Â  Â  <input id="inH" type="number" min="8" value="32" style="max-width:90px" />
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  </label>
Â  Â  Â  Â  Â  <label>
Â  Â  Â  Â  Â  Â  <span>Channels</span>
Â  Â  Â  Â  Â  Â  <select id="channels">
Â  Â  Â  Â  Â  Â  Â  <option value="3" selected>3 (RGB)</option>
Â  Â  Â  Â  Â  Â  Â  <option value="1">1 (Grayscale)</option>
Â  Â  Â  Â  Â  Â  </select>
Â  Â  Â  Â  Â  </label>
Â  Â  Â  Â  Â  <label>
Â  Â  Â  Â  Â  Â  <span>Color Order</span>
Â  Â  Â  Â  Â  Â  <select id="colorOrder">
Â  Â  Â  Â  Â  Â  Â  <option value="RGB" selected>RGB</option>
Â  Â  Â  Â  Â  Â  Â  <option value="BGR">BGR</option>
Â  Â  Â  Â  Â  Â  </select>
Â  Â  Â  Â  Â  </label>
Â  Â  Â  Â  Â  <label>
Â  Â  Â  Â  Â  Â  <span>Keep Aspect</span>
Â  Â  Â  Â  Â  Â  <select id="keepAspect">
Â  Â  Â  Â  Â  Â  Â  <option value="cover" selected>Center crop (cover)</option>
Â  Â  Â  Â  Â  Â  Â  <option value="contain">Letterbox (contain)</option>
Â  Â  Â  Â  Â  Â  Â  <option value="stretch">Stretch</option>
Â  Â  Â  Â  Â  Â  </select>
Â  Â  Â  Â  Â  </label>
Â  Â  Â  Â  </fieldset>

Â  Â  Â  Â  <fieldset style="margin-top: var(--gap)">
Â  Â  Â  Â  Â  <legend>Preprocessing</legend>
Â  Â  Â  Â  Â  <label>
Â  Â  Â  Â  Â  Â  <span>Mean (perâ€‘ch)</span>
Â  Â  Â  Â  Â  Â  <input id="mean" type="text" value="0.4914,0.4822,0.4465" />
Â  Â  Â  Â  Â  </label>
Â  Â  Â  Â  Â  <label>
Â  Â  Â  Â  Â  Â  <span>Std (perâ€‘ch)</span>
Â  Â  Â  Â  Â  Â  <input id="std" type="text" value="0.247,0.243,0.261" />
Â  Â  Â  Â  Â  </label>
Â  Â  Â  Â  Â  <label>
Â  Â  Â  Â  Â  Â  <span>Scale</span>
Â  Â  Â  Â  Â  Â  <select id="scale">
Â  Â  Â  Â  Â  Â  Â  <option value="1/255" selected>Divide by 255</option>
Â  Â  Â  Â  Â  Â  Â  <option value="none">No scaling</option>
Â  Â  Â  Â  Â  Â  </select>
Â  Â  Â  Â  Â  </label>
Â  Â  Â  Â  Â  <label>
Â  Â  Â  Â  Â  Â  <span>Layout</span>
Â  Â  Â  Â  Â  Â  <select id="layout">
Â  Â  Â  Â  Â  Â  Â  <option value="NCHW" selected>NCHW</option>
Â  Â  Â  Â  Â  Â  Â  <option value="NHWC">NHWC</option>
Â  Â  Â  Â  Â  Â  </select>
Â  Â  Â  Â  Â  </label>
Â  Â  Â  Â  </fieldset>

Â  Â  Â  Â  <fieldset style="margin-top: var(--gap)">
Â  Â  Â  Â  Â  <legend>Precision / Quantization</legend>
Â  Â  Â  Â  Â  <label>
Â  Â  Â  Â  Â  Â  <span>Input dtype</span>
Â  Â  Â  Â  Â  Â  <select id="dtype">
Â  Â  Â  Â  Â  Â  Â  <option value="float32" selected>float32</option>
Â  Â  Â  Â  Â  Â  Â  <option value="float16">float16 (FP16)</option>
Â  Â  Â  Â  Â  Â  Â  <option value="int8">int8 (é‡åŒ–)</option>
Â  Â  Â  Â  Â  Â  </select>
Â  Â  Â  Â  Â  </label>
Â  Â  Â  Â  Â  <div id="qInBox" class="hide">
Â  Â  Â  Â  Â  Â  <label>
Â  Â  Â  Â  Â  Â  Â  <span>IN scale</span>
Â  Â  Â  Â  Â  Â  Â  <input id="qInScale" type="number" step="any" value="0.02" />
Â  Â  Â  Â  Â  Â  </label>
Â  Â  Â  Â  Â  Â  <label>
Â  Â  Â  Â  Â  Â  Â  <span>IN zeroPoint</span>
Â  Â  Â  Â  Â  Â  Â  <input id="qInZero" type="number" step="1" value="0" />
Â  Â  Â  Â  Â  Â  </label>
Â  Â  Â  Â  Â  Â  <div class="hint">int8 æœƒä½¿ç”¨: q = round(x/scale) + zeroPointï¼Œä¸¦å¤¾åˆ° [âˆ’128,127]</div>
Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  <label>
Â  Â  Â  Â  Â  Â  <span>Output quantized?</span>
Â  Â  Â  Â  Â  Â  <select id="outQuant">
Â  Â  Â  Â  Â  Â  Â  <option value="no" selected>No</option>
Â  Â  Â  Â  Â  Â  Â  <option value="int8">Yes (int8)</option>
Â  Â  Â  Â  Â  Â  </select>
Â  Â  Â  Â  Â  </label>
Â  Â  Â  Â  Â  <div id="qOutBox" class="hide">
Â  Â  Â  Â  Â  Â  <label>
Â  Â  Â  Â  Â  Â  Â  <span>OUT scale</span>
Â  Â  Â  Â  Â  Â  Â  <input id="qOutScale" type="number" step="any" value="0.04" />
Â  Â  Â  Â  Â  Â  </label>
Â  Â  Â  Â  Â  Â  <label>
Â  Â  Â  Â  Â  Â  Â  <span>OUT zeroPoint</span>
Â  Â  Â  Â  Â  Â  Â  <input id="qOutZero" type="number" step="1" value="0" />
Â  Â  Â  Â  Â  Â  </label>
Â  Â  Â  Â  Â  Â  <div class="hint">å°‡è¼¸å‡ºåé‡åŒ–: x = (q - zeroPoint) * scale</div>
Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  </fieldset>

Â  Â  Â  Â  <fieldset style="margin-top: var(--gap)">
Â  Â  Â  Â  Â  <legend>Postâ€‘processing</legend>
Â  Â  Â  Â  Â  <label>
Â  Â  Â  Â  Â  Â  <span>Topâ€‘K</span>
Â  Â  Â  Â  Â  Â  <input id="topk" type="number" min="1" max="10" value="3" />
Â  Â  Â  Â  Â  </label>
Â  Â  Â  Â  Â  <label>
Â  Â  Â  Â  Â  Â  <span>Classes (CSV)</span>
Â  Â  Â  Â  Â  Â  <input id="classes" type="text" value="airplane,automobile,bird,cat,deer,dog,frog,horse,ship,truck" />
Â  Â  Â  Â  Â  </label>
Â  Â  Â  Â  </fieldset>
Â  Â  Â  </div>
Â  Â  </div>
Â  </div>

<script>
(() => {
Â  const $ = (id) => document.getElementById(id);
Â  const els = {
Â  Â  status: $("status"), epLabel: $("epLabel"), log: $("log"),
Â  Â  file: $("file"), drop: $("drop"), preview: $("preview"),
Â  Â  pred1: $("pred1"), pred2: $("pred2"), pred3: $("pred3"),
Â  Â  loadBtn: $("loadBtn"), runBtn: $("runBtn"), compareBtn: $("compareBtn"), // â­ æ–°å¢ compareBtn
Â  Â  modelUrlFP32: $("modelUrlFP32"), modelUrlINT8: $("modelUrlINT8"), // â­ æ–°å¢é›™æ¨¡å‹ URL
Â  Â  provider: $("provider"), compareResult: $("compareResult"), // â­ æ–°å¢æ¯”è¼ƒçµæœ DIV
Â  Â  inW: $("inW"), inH: $("inH"), channels: $("channels"), colorOrder: $("colorOrder"), keepAspect: $("keepAspect"),
Â  Â  mean: $("mean"), std: $("std"), scale: $("scale"), layout: $("layout"),
Â  Â  dtype: $("dtype"), qInBox: $("qInBox"), qInScale: $("qInScale"), qInZero: $("qInZero"),
Â  Â  outQuant: $("outQuant"), qOutBox: $("qOutBox"), qOutScale: $("qOutScale"), qOutZero: $("qOutZero"),
Â  Â  topk: $("topk"), classes: $("classes"),
Â  };

Â  /*** Utilities ***/
Â  const log = (msg) => { console.log(msg); els.log.textContent = String(msg); };
Â  const logAdd = (msg) => { console.log(msg); els.log.textContent += "\n" + msg; };
Â  const parseCSV = (txt, fallback=[]) => {
Â  Â  try { const arr = txt.split(',').map(s => s.trim()).filter(Boolean); return arr.length ? arr : fallback; } catch { return fallback; }
Â  };
Â  const parseCSVNums = (txt, fallback=[]) => {
Â  Â  const arr = parseCSV(txt, []).map(Number).map(v => Number.isFinite(v) ? v : NaN);
Â  Â  return arr.every(Number.isFinite) && arr.length ? arr : fallback;
Â  };
Â  const softmax = (logits) => {
Â  Â  const max = Math.max(...logits);
Â  Â  const exps = logits.map(v => Math.exp(v - max));
Â  Â  const sum = exps.reduce((a,b)=>a+b,0);
Â  Â  return exps.map(v => v / (sum || 1));
Â  };
Â  const topK = (probs, k=3) => probs.map((p,i)=>[i,p]).sort((a,b)=>b[1]-a[1]).slice(0, k);

Â  // float32 -> IEEE754 half (Uint16) è½‰æ› (ä¿ç•™åŸå§‹è¤‡é›œåŠŸèƒ½)
Â  function f32ToF16Bits(val) {
Â  Â  const f32 = new Float32Array(1); const u32 = new Uint32Array(f32.buffer);
Â  Â  f32[0] = val; const x = u32[0];
Â  Â  const sign = (x >>> 31) & 0x1;
Â  Â  let exp = (x >>> 23) & 0xFF;
Â  Â  let mant = x & 0x7FFFFF;
Â  Â  if (exp === 0xFF) { const f16 = (sign<<15) | 0x7C00 | (mant ? 0x200 : 0); return f16; }
Â  Â  if (exp === 0) { if (mant === 0) return sign<<15; else { while ((mant & 0x800000) === 0) { mant <<= 1; exp--; } exp++; mant &= ~0x800000; } }
Â  Â  exp = exp - 127 + 15;
Â  Â  if (exp >= 0x1F) { return (sign<<15) | 0x7C00; }
Â  Â  if (exp <= 0) { if (exp < -10) return sign<<15; mant = (mant | 0x800000) >> (1 - exp); const halfMant = (mant + 0x1000) >> 13; return (sign<<15) | halfMant; }
Â  Â  const halfMant = (mant + 0x1000) >> 13;
Â  Â  return (sign<<15) | (exp<<10) | (halfMant & 0x3FF);
Â  }

Â  /*** Configuration ***/
Â  const getCfg = () => ({
Â  Â  modelUrlFP32: els.modelUrlFP32.value.trim() || './resnet_exported.onnx', // â­ è®€å– FP32 URL
Â  Â  modelUrlINT8: els.modelUrlINT8.value.trim() || './image_classifier_model_int8.onnx', // â­ è®€å– INT8 URL
Â  Â  provider: els.provider.value,
Â  Â  W: Math.max(8, parseInt(els.inW.value, 10) || 32),
Â  Â  H: Math.max(8, parseInt(els.inH.value, 10) || 32),
Â  Â  C: parseInt(els.channels.value, 10) || 3,
Â  Â  colorOrder: els.colorOrder.value,
Â  Â  keepAspect: els.keepAspect.value,
Â  Â  mean: parseCSVNums(els.mean.value, [0.4914, 0.4822, 0.4465]),
Â  Â  std: parseCSVNums(els.std.value, [0.247, 0.243, 0.261]),
Â  Â  scale: els.scale.value,
Â  Â  layout: els.layout.value,
Â  Â  dtype: els.dtype.value,
Â  Â  qInScale: Number(els.qInScale.value) || 1, qInZero: Math.round(Number(els.qInZero.value) || 0),
Â  Â  outQuant: els.outQuant.value, qOutScale: Number(els.qOutScale.value) || 1, qOutZero: Math.round(Number(els.qOutZero.value) || 0),
Â  Â  topk: Math.max(1, Math.min(10, parseInt(els.topk.value,10) || 3)),
Â  Â  classes: parseCSV(els.classes.value, [
Â  Â  Â  'airplane','automobile','bird','cat','deer','dog','frog','horse','ship','truck'
Â  Â  ]),
Â  });

Â  /*** Global State ***/
Â  let sessionFP32 = null; // â­ FP32 Session
Â  let sessionINT8 = null; // â­ INT8 Session
Â  let lastLoadKey = '';
Â  let imageBitmap = null; // decoded input image

Â  /*** Model Loading ***/
Â  async function tryCreateSession(url, so) {
Â  Â  try { return await ort.InferenceSession.create(url, so); } catch (e) { throw e; }
Â  }

Â  async function loadModel() {
Â  Â  const cfg = getCfg();
    // æª¢æŸ¥å…©å€‹æ¨¡å‹çš„ç‹€æ…‹
Â  Â  const key = `${cfg.modelUrlFP32}|${cfg.modelUrlINT8}|${cfg.provider}`;
Â  Â  if (sessionFP32 && sessionINT8 && key === lastLoadKey) { 
        logAdd('Models already loaded.'); 
        els.status.textContent = 'Loaded';
        return true; 
    }
    
    // æ¸…é™¤èˆŠçš„ session
    sessionFP32 = null; sessionINT8 = null;

Â  Â  els.status.textContent = 'Loadingâ€¦';
Â  Â  log(`Loading models (FP32: ${cfg.modelUrlFP32}, INT8: ${cfg.modelUrlINT8}) (EP=${cfg.provider})`);

Â  Â  const primary = { executionProviders: [cfg.provider], graphOptimizationLevel: 'all' };
Â  Â  const fallback = { executionProviders: ['wasm'], graphOptimizationLevel: 'all' };

Â  Â  try {
        // --- è¼‰å…¥ FP32 (å« fallback) ---
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  sessionFP32 = await tryCreateSession(cfg.modelUrlFP32, primary);
Â  Â  Â  Â  Â  els.epLabel.textContent = cfg.provider;
Â  Â  Â  Â  } catch (e) {
Â  Â  Â  Â  Â  if (cfg.provider === 'webgl') {
Â  Â  Â  Â  Â  Â  logAdd(`FP32 EP=webgl failed â†’ fallback to wasm. Reason: ${e.message}`);
Â  Â  Â  Â  Â  Â  sessionFP32 = await tryCreateSession(cfg.modelUrlFP32, fallback);
Â  Â  Â  Â  Â  Â  els.epLabel.textContent = 'wasm (fallback)';
Â  Â  Â  Â  Â  Â  els.provider.value = 'wasm';
Â  Â  Â  Â  Â  } else { throw e; }
Â  Â  Â  Â  }

        // --- è¼‰å…¥ INT8 (ä½¿ç”¨ç¢ºå®šçš„ EP) ---
        logAdd(`Loading INT8 model...`);
        sessionINT8 = await tryCreateSession(cfg.modelUrlINT8, { executionProviders: [els.provider.value], graphOptimizationLevel: 'all' });
        
Â  Â  Â  Â  lastLoadKey = key;
Â  Â  Â  Â  els.status.textContent = 'Loaded';

Â  Â  Â  Â  const inName = sessionFP32.inputNames[0];
Â  Â  Â  Â  const meta = sessionFP32.inputMetadata?.[inName];
Â  Â  Â  Â  let dims = meta?.dims || [1, cfg.C, cfg.H, cfg.W];
Â  Â  Â  Â  dims = dims.map((d, i) => (typeof d === 'number' && d > 0) ? d : ([1, cfg.C, cfg.H, cfg.W][i] ?? 1));
Â  Â  Â  Â  log(`Models loaded. FP32 Input: ${inName} â†’ [${dims.join(', ')}], type=${meta?.type || 'unknown'}. INT8 loaded successfully.`);
Â  Â  Â  Â  return true;
Â  Â  } catch (err) {
Â  Â  Â  els.status.textContent = 'Error';
Â  Â  Â  console.error(err); log(`Failed to load model(s): ${err.message}\n${err.stack || ''}`);
Â  Â  Â  sessionFP32 = null; sessionINT8 = null; lastLoadKey = '';
Â  Â  Â  return false;
Â  Â  }
Â  }

Â  /*** Image IO ***/
Â  function installDrop() {
Â  Â  const onFiles = async (files) => {
Â  Â  Â  const f = files?.[0]; if (!f) return;
Â  Â  Â  try {
Â  Â  Â  Â  const img = await createImageBitmap(f);
Â  Â  Â  Â  imageBitmap = img;
Â  Â  Â  Â  const url = URL.createObjectURL(f);
Â  Â  Â  Â  els.preview.src = url;
Â  Â  Â  Â  logAdd(`Image loaded: ${f.name} (${img.width}Ã—${img.height})`);
Â  Â  Â  } catch (e) { console.error(e); logAdd(`Image decode failed: ${e.message}`); }
Â  Â  };

Â  Â  els.file.addEventListener('change', (e) => onFiles(e.target.files));
Â  Â  els.drop.addEventListener('click', () => els.file.click());

Â  Â  const d = els.drop;
Â  Â  d.addEventListener('dragover', (e)=>{ e.preventDefault(); d.classList.add('drag'); });
Â  Â  d.addEventListener('dragleave', ()=> d.classList.remove('drag'));
Â  Â  d.addEventListener('drop', (e)=>{ e.preventDefault(); d.classList.remove('drag'); onFiles(e.dataTransfer.files); });
Â  }

Â  /*** Preprocess ***/
Â  function drawToCanvas(img, W, H, mode='cover') {
Â  Â  let canvas;
Â  Â  if (typeof OffscreenCanvas !== 'undefined') { canvas = new OffscreenCanvas(W, H); }
Â  Â  else { canvas = document.createElement('canvas'); canvas.width = W; canvas.height = H; }
Â  Â  const g = canvas.getContext('2d');
Â  Â  g.imageSmoothingEnabled = true;

Â  Â  if (mode === 'stretch') { g.drawImage(img, 0, 0, W, H); }
Â  Â  else {
Â  Â  Â  const rImg = img.width / img.height; const rDst = W / H;
Â  Â  Â  let dw=W, dh=H, dx=0, dy=0;
Â  Â  Â  if (mode === 'cover') {
Â  Â  Â  Â  if (rImg > rDst) { dh = H; dw = H * rImg; dx = (W - dw) / 2; dy = 0; }
Â  Â  Â  Â  else { dw = W; dh = W / rImg; dx = 0; dy = (H - dh) / 2; }
Â  Â  Â  } else { // contain
Â  Â  Â  Â  if (rImg > rDst) { dw = W; dh = W / rImg; dx = 0; dy = (H - dh) / 2; }
Â  Â  Â  Â  else { dh = H; dw = H * rImg; dx = (W - dw) / 2; dy = 0; }
Â  Â  Â  }
Â  Â  Â  g.fillStyle = '#000'; g.fillRect(0,0,W,H);
Â  Â  Â  g.drawImage(img, dx, dy, dw, dh);
Â  Â  }
Â  Â  return g.getImageData(0,0,W,H);
Â  }

Â  function preprocess(img, cfg) {
Â  Â  const { W,H,C, colorOrder, mean, std, scale, layout, dtype, qInScale, qInZero } = cfg;
Â  Â  const rgba = drawToCanvas(img, W, H, cfg.keepAspect).data;

Â  Â  const N = 1; const size = layout === 'NCHW' ? N*C*H*W : N*H*W*C;
Â  Â  const scaleFactor = scale === '1/255' ? 1/255 : 1;
Â  Â  const chIndex = (c) => { if (C===1) return 0; if (colorOrder==='RGB') return c; return c===0?2:(c===2?0:1); };

Â  Â  const f32 = new Float32Array(size);

Â  Â  for (let y=0; y<H; y++) {
Â  Â  Â  for (let x=0; x<W; x++) {
Â  Â  Â  Â  const srcIdx = (y*W + x) * 4;
Â  Â  Â  Â  const r = rgba[srcIdx + 0] * scaleFactor;
Â  Â  Â  Â  const g = rgba[srcIdx + 1] * scaleFactor;
Â  Â  Â  Â  const b = rgba[srcIdx + 2] * scaleFactor;
Â  Â  Â  Â  const gray = (r + g + b) / 3;
Â  Â  Â  Â  for (let c=0; c<C; c++) {
Â  Â  Â  Â  Â  const valRaw = C===1 ? gray : (chIndex(c)===0?r : chIndex(c)===1?g : b);
Â  Â  Â  Â  Â  const mu = mean[Math.min(c, mean.length-1)] ?? 0;
Â  Â  Â  Â  Â  const sd = std[Math.min(c, std.length-1)] ?? 1;
Â  Â  Â  Â  Â  const norm = (valRaw - mu) / (sd || 1);
Â  Â  Â  Â  Â  if (layout === 'NCHW') {
Â  Â  Â  Â  Â  Â  const dst = c*(H*W) + y*W + x; f32[dst] = norm;
Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  const dst = (y*W + x)*C + c; f32[dst] = norm;
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  }

Â  Â  let data, type;
Â  Â  if (dtype === 'float32') { data = f32; type = 'float32'; }
Â  Â  else if (dtype === 'float16') {
Â  Â  Â  const u16 = new Uint16Array(size);
Â  Â  Â  for (let i=0;i<size;i++) u16[i] = f32ToF16Bits(f32[i]);
Â  Â  Â  data = u16; type = 'float16';
Â  Â  } else { // int8
Â  Â  Â  const q = new Int8Array(size);
Â  Â  Â  const s = qInScale || 1; const zp = qInZero || 0;
Â  Â  Â  for (let i=0;i<size;i++) {
Â  Â  Â  Â  const v = Math.round(f32[i]/s + zp);
Â  Â  Â  Â  q[i] = Math.max(-128, Math.min(127, v));
Â  Â  Â  }
Â  Â  Â  data = q; type = 'int8';
Â  Â  }

Â  Â  const shape = layout === 'NCHW' ? [1, C, H, W] : [1, H, W, C];
Â  Â  return { data, shape, type };
Â  }
  
  /*** Post-process and Compare ***/
Â  function compareResults(outFP32, outINT8, msFP32, msINT8, cfg) {
Â  Â  Â  // è¼”åŠ©å‡½å¼ï¼šæå– Top K çµæœä¸¦è™•ç†åé‡åŒ–
      function getTopK(out, isQuant) {
          const outData = out.data;
          
          let logits;
          if (isQuant && (out.type === 'int8' || out.type === 'uint8')) {
              const s = cfg.qOutScale || 1; const zp = cfg.qOutZero || 0;
              const raw = Array.from(outData);
              logits = raw.map(v => (Number(v) - zp) * s);
          } else {
              logits = Array.from(outData);
          }

          const probs = softmax(logits);
          const top = topK(probs, cfg.topk).map(([i,p]) => ({ idx:i, prob:p, name: cfg.classes[i] ?? `#${i}` }));
          return top;
      }
      
      const topFP32 = getTopK(outFP32, false);
      const topINT8 = getTopK(outINT8, cfg.outQuant === 'int8');

      const speedup = (msFP32 / msINT8); // åŠ é€Ÿæ¯”
      const topClassFP32 = topFP32[0]?.name ?? 'N/A';
      const topClassINT8 = topINT8[0]?.name ?? 'N/A';
      const classMatch = (topClassFP32 === topClassINT8) ? "âœ… ç›¸åŒ" : "âŒ ä¸åŒ";
      
      logAdd(`Comparison: FP32 time ${msFP32.toFixed(2)} ms, INT8 time ${msINT8.toFixed(2)} ms. Speedup: ${speedup.toFixed(2)}x`);

      let html = `
          <h3 style="margin: 0 0 10px;">ğŸ“Š æ€§èƒ½èˆ‡æº–ç¢ºåº¦æ¯”è¼ƒ</h3>
          <div style="display: flex; gap: 20px; flex-wrap: wrap; margin-bottom: 15px;">
              <div class="pill" style="background: #17332c; border-color: #3b6b66;">
                  <strong>FP32 Time:</strong> ${msFP32.toFixed(2)} ms
              </div>
              <div class="pill" style="background: #33172c; border-color: #6b3b66;">
                  <strong>INT8 Time:</strong> ${msINT8.toFixed(2)} ms
              </div>
              <div class="pill" style="background: #202e53; border-color: #3f558a;">
                  <strong>Speedup (FP32/INT8):</strong> <span style="font-weight: bold; color: #8af;">${speedup.toFixed(2)}Ã—</span>
              </div>
              <div class="pill" style="background: #3a2e1d; border-color: #7d6b4d;">
                  <strong>Top Class Match:</strong> ${classMatch}
              </div>
          </div>
          
          <div class="flex">
              <div class="grow card" style="background: #151d32;">
                  <h4>FP32 (Original) Top ${cfg.topk}</h4>
                  ${topFP32.map(t => 
                      `<p style="margin: 5px 0;"><strong>${t.name}:</strong> ${(t.prob*100).toFixed(2)}%</p>`
                  ).join('')}
              </div>
              <div class="grow card" style="background: #151d32;">
                  <h4>INT8 (Quantized) Top ${cfg.topk}</h4>
                  ${topINT8.map(t => 
                      `<p style="margin: 5px 0;"><strong>${t.name}:</strong> ${(t.prob*100).toFixed(2)}%</p>`
                  ).join('')}
              </div>
          </div>
      `;
      els.compareResult.innerHTML = html;
      
      // æ›´æ–° Top 3 Badge (é¡¯ç¤º FP32 çµæœ)
      [els.pred1, els.pred2, els.pred3].forEach((el, i) => {
          if (!el) return; const t = topFP32[i];
          el.textContent = t ? `${t.name}: ${(t.prob*100).toFixed(1)}%` : 'â€”';
      });

Â  }


Â  async function runComparison() {
Â  Â  const cfg = getCfg();
Â  Â  if (!sessionFP32 || !sessionINT8) { 
        log('Models are not loaded. Attempting to load...');
        const loaded = await loadModel();
        if (!loaded) return; 
    }
Â  Â  if (!imageBitmap) { log('Please select an image first.'); return; }

Â  Â  els.status.textContent = 'Preprocessingâ€¦';
Â  Â  
Â  Â  const inputName = sessionFP32.inputNames[0];

Â  Â  let dims = null;
Â  Â  try { dims = sessionFP32.inputMetadata?.[inputName]?.dims ?? null; } catch {}

Â  Â  const W = (Array.isArray(dims) && dims.length >= 4 && Number(dims[dims.length-1]) > 0)
Â  Â  Â  ? Number(dims[dims.length-1]) : cfg.W;
Â  Â  const H = (Array.isArray(dims) && dims.length >= 4 && Number(dims[dims.length-2]) > 0)
Â  Â  Â  ? Number(dims[dims.length-2]) : cfg.H;
Â  Â  const C = cfg.C;

Â  Â  // 1. å‰è™•ç† (åªåšä¸€æ¬¡)
Â  Â  const pp = preprocess(imageBitmap, { ...cfg, W, H, C });

Â  Â  let tensor;
Â  Â  try {
Â  Â  Â  tensor = new ort.Tensor(pp.type, pp.data, pp.shape);
Â  Â  } catch (e) {
Â  Â  Â  log(`Failed to create tensor with type=${pp.type}. Check Model/Input settings.\n${e.message}`);
Â  Â  Â  els.status.textContent = 'Error';
Â  Â  Â  return;
Â  Â  }

Â  Â  const feeds = { [inputName]: tensor };

Â  Â  els.status.textContent = 'Running FP32 Inferenceâ€¦';
Â  Â  log(`Running FP32 inferenceâ€¦ Input: ${inputName} â† ${pp.shape.join('Ã—')} (${pp.type})`);
Â  Â  
Â  Â  let outFP32, outINT8;
Â  Â  let msFP32, msINT8;

Â  Â  try { 
        // 2. åŸ·è¡Œ FP32
        const t0_fp32 = performance.now();
        const outMapFP32 = await sessionFP32.run(feeds); 
        msFP32 = performance.now() - t0_fp32;
        outFP32 = outMapFP32[sessionFP32.outputNames[0]];

        els.status.textContent = 'Running INT8 Inferenceâ€¦';
        logAdd(`FP32 Done: ${msFP32.toFixed(2)} ms. Running INT8 inferenceâ€¦`);

        // 3. åŸ·è¡Œ INT8
        const t0_int8 = performance.now();
        const outMapINT8 = await sessionINT8.run(feeds); 
        msINT8 = performance.now() - t0_int8;
        outINT8 = outMapINT8[sessionINT8.outputNames[0]];

Â  Â  } catch (err) { 
        console.error(err); 
        log(`Inference failed: ${err.message}\n${err.stack || ''}`); 
        els.status.textContent='Error'; 
        return; 
    }

Â  Â  // 4. æ¯”è¼ƒèˆ‡é¡¯ç¤ºçµæœ
Â  Â  compareResults(outFP32, outINT8, msFP32, msINT8, cfg);

Â  Â  els.status.textContent = 'Comparison Done';
Â  }
  
  // ç‚ºäº†ä¿æŒç¨‹å¼ç¢¼çµæ§‹çš„å®Œæ•´æ€§ï¼Œå°‡ runOnce å°å‘ runComparison
  const runOnce = runComparison; 

Â  /*** Wireâ€‘up ***/
Â  function updateQuantUI() {
Â  Â  const dt = els.dtype.value;
Â  Â  els.qInBox.classList.toggle('hide', dt !== 'int8');
Â  Â  els.qOutBox.classList.toggle('hide', els.outQuant.value !== 'int8');
Â  }
Â  els.dtype.addEventListener('change', updateQuantUI);
Â  els.outQuant.addEventListener('change', updateQuantUI);
Â  updateQuantUI();

Â  installDrop();
Â  els.loadBtn.addEventListener('click', loadModel);
Â  els.compareBtn.addEventListener('click', runComparison); 
Â  els.runBtn.addEventListener('click', runComparison); 

Â  // é è¨­è‡ªå‹•è¼‰å…¥ä¸€æ¬¡
Â  loadModel().catch(()=>{});
})();
</script>
</body>
</html>
